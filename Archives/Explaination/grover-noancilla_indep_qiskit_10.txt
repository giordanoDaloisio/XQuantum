In quantum computing, Grover's algorithm, also known as the quantum search algorithm, is a quantum algorithm for unstructured search that finds with high probability the unique input to a black box function that produces a particular output value, using just O(sqrt(N))evaluations of the function, where N is the size of the function's domain. It was devised by Lov Grover in 1996.

The analogous problem in classical computation cannot be solved in fewer than O(N) evaluations (because, on average, one has to check half of the domain to get a 50% chance of finding the right input). Charles H. Bennett, Ethan Bernstein, Gilles Brassard, and Umesh Vazirani proved that any quantum solution to the problem needs to evaluate the function Î©(sqrt(N)) times, so Grover's algorithm is asymptotically optimal. Since classical algorithms for NP-complete problems require exponentially many steps, and Grover's algorithm provides at most a quadratic speedup over the classical solution for unstructured search, this suggests that Grover's algorithm by itself will not provide polynomial-time solutions for NP-complete problems (as the square root of an exponential function is an exponential, not polynomial, function).[3]

Unlike other quantum algorithms, which may provide exponential speedup over their classical counterparts, Grover's algorithm provides only a quadratic speedup. However, even quadratic speedup is considerable when N is large, and Grover's algorithm can be applied to speed up broad classes of algorithms. Grover's algorithm could brute-force a 128-bit symmetric cryptographic key in roughly 264 iterations, or a 256-bit key in roughly 2128 iterations. It may not be the case that Grover's algorithm poses a significantly increased risk to encryption over existing classical algorithms, however.

As input for Grover's algorithm, suppose we have a function \( f: \{0,1,\ldots,N-1\} \to \{0,1\} \). In the "unstructured database" analogy, the domain represents indices to a database, and \( f(x) = 1 \) if and only if the data that \( x \) points to satisfies the search criterion. We additionally assume that only one index satisfies \( f(x) = 1 \), and we call this index \( \omega \). Our goal is to identify \( \omega \).

We can access \( f \) with a subroutine (sometimes called an oracle) in the form of a unitary operator \( U_\omega \) that acts as follows:

\[
\begin{cases}
U_{\omega}|x\rangle =-|x\rangle & \text{for } x=\omega \text{, that is, } f(x)=1,\\
U_{\omega}|x\rangle =|x\rangle & \text{for } x\neq \omega \text{, that is, } f(x)=0.
\end{cases}
\]

This uses the \( N \)-dimensional state space \( \mathcal{H} \), which is supplied by a register with \( n = \lceil \log_2 N \rceil \) qubits. This is often written as

\[ U_{\omega}|x\rangle = (-1)^{f(x)}|x\rangle. \]

Grover's algorithm outputs \( \omega \) with probability at least \( 1/2 \) using \( O(\sqrt{N}) \) applications of \( U_\omega \). This probability can be made arbitrarily large by running Grover's algorithm multiple times. If one runs Grover's algorithm until \( \omega \) is found, the expected number of applications is still \( O(\sqrt{N}) \), since it will only be run twice on average.

The steps of Grover's algorithm are as follows:

1. Initialize the system to the uniform superposition over all states:

\[ |s\rangle = \frac{1}{\sqrt{N}} \sum_{x=0}^{N-1} |x\rangle. \]

2. Perform the following "Grover iteration" \( r(N) \) times:
   - Apply the operator \( U_{\omega} \).
   - Apply the Grover diffusion operator:
     \[ U_s = 2|s\rangle \langle s| - I. \]
   - Measure the resulting quantum state in the computational basis.

For the correctly chosen value of \( r \), the output will be \( |\omega \rangle \) with probability approaching 1 for \( N \gg 1 \). Analysis shows that the eventual value for \( r(N) \) satisfies \( r(N) \leq \lceil \frac{\pi}{4} \sqrt{N} \rceil \).

Implementing the steps for this algorithm can be done using a number of gates linear in the number of qubits. Thus, the gate complexity of this algorithm is \( O(\log(N) r(N)) \), or \( O(\log(N)) \) per iteration.
